ZeroTier Mapping for Scalability Protocols
===========================================

sp-zerotier-mapping-02
~~~~~~~~~~~~~~~~~~~~~~

Abstract
--------

This document defines the ZeroTier mapping for scalability protocols.

Status of This Memo
-------------------

This is the second draft document, and is intended to guide early
development efforts.  Nothing here is finalized yet.

Copyright Notice
----------------

Copyright 2017 Garrett D'Amore <garrett@damore.org> +
Copyright 2017 Capitar IT Group BV <info@capitar.com>

At this point, all rights are reserved. (Note that we do intend to
release this under a liberal reuse license once it stabilizes a bit.)

Underlying protocol
-------------------

ZeroTier expresses an 802.3 style layer 2, where frames maybe excchanged as if
they were Ethernet frames.  Virtual broadcast domains are created within a
numbered "network", and frames may then be exchanged with any peers on that
network.

Frames may arrive in any order, or be lost, just a with Ethernet
(best effort delivery), but they are strongly protected by a
cryptographic checksum, so frames that do arrive will be uncorrupted.
Furthermore, ZeroTier guarantees that a given frame will be received
at most once.

Each application on a ZeroTier network has its own address, called a
ZeroTier ID (`ZTID`), which is globally unique -- this is generated
from a hash of the public key associated with the application.

A given application may participate in multiple ZeroTier networks.

We assume each SP application will have it's own ZeroTier ID,
and will not use more than one.  Management of these IDs, as well as
the underlying key pairs, is out of scope of this document.

ZeroTier networks have a standard MTU of 2800 bytes.
They may be configured to have larger MTUs, but typically this involves
extensive reassembly at underlying layers, and so larger MTUs are not
used in this specification.

They also have an "optimum" MTU, based upon the underlying networks
(typically UDP) and overheads that are used to exchange such packets.
For our purposes we will assume this to be approximately 1400 bytes.
These values can change on different networks.

Packet layout
~~~~~~~~~~~~~

Each SP message sent over ZeroTier will be comprised of one or
more fragments, where each fragment is mapped to a single underlying
ZeroTier L2 frame.  We use the EtherType field of 0901 to indicate
SP over ZeroTier protocol (number to registered with IEEE).

Each frame shall be prepended with the following header:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              destination mac address (bytes 0-3)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  destination mac (bytes 4-5)  |    source mac (bytes 0-1)     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   source mac address (bytes 2-5)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    0x90       |   0x01        |  op   | flags |   version     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        fragment offset        |       fragment length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        destination port       |         source port           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          type                 |           message ID          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       payload...
   +-+-+-+-+-+-+-+-

All numeric fields are in big-endian byte order.

As above, the start of each frame is just as a normal Ethernet frame,
with destination, source, and type of 0x901.

The `op` is a field that indicates the type of message being sent.  The
following values are defined: `DATA` (0), `CONN` (1), `DISC` (2), `PING` (3),
and `ERR` (4).  These are discussed further below.  Implementations
*MUST* discard messages where the `op` is not one of these.

There are two `flags` defined.  The first is `MF` (1), which indicates
that a message is fragmented, and more fragments follow.  This flag
may only be set on `DATA` messages.  The last fragment of a message
will not have this flag set.

The second flag is `AK` (2), which indicates that a given message is a
reply to an earlier message.  This is only valid for the `CONN`, `DISC`,
and `PING` message types.

Note that the `MF` and the `AK` flag bits are mutually exclusive.

The `version` byte MUST be set to 0x1.  Implementations *MUST* discard
any messages received for any other version.

The fragment length and offset are given in terms of octets, and only
include the payload.  For example, the first fragment of a message
bearing a 2000 byte payload, itself only carrying 1400 bytes of that
payload would have the `MF` bit set in flags, offset 0, and length
1400.  The second fragment would have the `MF` bit clear, length 600,
and offset 1400.

As a single fragment cannot exceed the size of a ZeroTier frame, the
high order six bits of the fragment length *MUST* be zero, and the
value encoded MUST be less than 2800.

Each fragment for a given message must carry the same `message ID`.
Implementations MUST initialize this to a random value, and *MUST*
increment this each time a new message is sent.

The port fields are used to discriminate different uses, allowing one
application to have multiple connections or sockets open.  The
purpose is analogous to TCP port numbers, except that instead of the
operating system performing the discrimination the application or
library code must do so.

The `type` field is the numeric SP protocol ID, in big-endian form.
When receiving a message for a port, if the SP protocol ID does not
match the SP protocol expected on that port, the implementation *MUST*
discard this message.

The maximum payload size, and hence the maximum SP message that may
be transmitted using this transport, is 65535 octets.
Implementations are encouraged to restrict this further.

Note that it is not by accident that the payload is 32-bit aligned in
this message format.

Source and destination MAC addresses shall be constructed
algorithmically from the relevant ZeroTier IDs.

Note that at this time, broadcast and multicast is not supported by
this mapping.  (A future update may resolve this.)

DATA messages
~~~~~~~~~~~~~

`DATA` messages carry SP protocol payload data.  They can only be sent
on an established session (see `CONN` messages below), and are never
acknowledged.

CONN messages
~~~~~~~~~~~~~

`CONN` frames represent a session establishment.  They allow a peer to
advertise its port number to a remote peer, and to verify that a peer
is responsive.  The payload for the `CONN` frame is a 4 byte (big-endian)
value, consisting of the SP protocol ID of the sender.

The connection is initiated by the initiator sending this message,
with its own SP protocol ID.  The `AK` flag will in this case be clear.
The initiator must choose a `source port` number that is not currently
being used with the remote peer.  (Port numbers used for communication
with other network peers may be used...)

// There are some good questions here regarding port conflicts.  We'd
// like to have each party choose a unique ephemeral port number, that
// way we can generate a 32-bit hash ID which we can use for idhash
// table lookups.
//
// One idea we can explore here is the idea that listening ports (rendezvous
// ports) can be unique, since they only appear in the CONN message, and
// would need not be directed elsewhere.
//
// The other point of realization is that a server will always know whether
// it can safely reuse one *it's* ephemeral IDs, because it knows the client
// ID apriori (given to it at connect.)
//
// Clients need to chooes a unique ephemeral ID for each connection, since
// they have no idea what ID a server might give back.  Another way to
// deal with this is that we would just disconnect (drop the connection)
// if the negotiated ID would conflict with an entry we already have in the
// table.  The likelhood of collisions should be sufficiently rare that this
// approach may be sufficient.
//
// Finally, any 32-bit session ID (formulated by the port pairs) needs to
// be held in the table until both client and server have negotiated
// the close, in order to avoid collisions in the sessions.

The responder will acknowledge this by replying with its SP protocol
ID in the 4-byte payload, with the `AK` flag set.

Alternatively, a responder may reject the connection attempt by
sending a suitably formed ERR message (see below).

If a sender does not receive a reply, it SHOULD retry this message
before giving up and reporting an error to the user.

If a `CONN` frame is received for a session that already exists, the
receiver MUST reply.  The `CONN` request is idempotent.

DISC messages
~~~~~~~~~~~~~

DISC messages are used to request a session be terminated.  This
notifies the remote sender that no more data will be sent or
accepted, and the session resources may be released.  There is no
payload.  The party closing the session sends this with the AK flag
clear.  There is no acknowledgement.

// Note that we might want an AK, to clear the session cache.  That
// said, given that we have relatively short RTTs I think we can
// fairly easily ignore this by just keeping the tables on an expiry
// list.

PING messages
~~~~~~~~~~~~~

In order to keep session state, implementations will generally store
data for each session.  In order to prevent a stale session from
consuming these resources forever, and in order to keep underlying
ZeroTier sessions alive, a `PING` message may be sent.  This message
has no payload.

The sender *MUST* leave the `AK` bit clear.  If the `PING` is is
successful, then the responder *MUST* reply with a `PING` message with
the AK bit set.

In the event of an error, an implemenation _MAY_ reply with an `ERR`
message.

Implementations *MUST* not initiate `PING` messages if they have either
received or sent other session messages recently.

Implemenations shall use a timeout T1 seconds of be used before
initiating a message the first time, and that in the absence of a
reply, up to N further attempts be made, separated by T2 seconds.  If
no reply to the Nth attempt is received after T2 seconds have passed,
then the remote peer should be assumed offline or dead, and the
session closed.

It is recommended that T1, T2, and N all be configurable, with
recommended default values of 60, 10, and 5.  With these values,
sessions that appear dead after 2 minutes will be closed, and their
resources reclaimed.

ERR messages
~~~~~~~~~~~~

`ERR` messages indicate a failure in the session, and abruptly
terminate the session.  The payload for these messages consists of a
single byte error code, followed by an ASCII message describing the
error (not terminated by zero).  This message *MUST NOT* be more than
128 bytes in length.

The following error codes are defined:

     * 0x01 No party listening at that address or port.
     * 0x02 No such session found.
     * 0x03 SP protocol ID invalid.
     * 0x04 Generic protocol error.
     * 0x05 Message size too big.
     * 0xff Other uncategorized error.

Implemenations *MUST* discard any session state upon receiving an ERR
message.  These messages are not acknowledged.

Reassembly Guidelines
~~~~~~~~~~~~~~~~~~~~~

Implementations *MUST* accept and reassemble fragmented `DATA` messages.
Implementations *MUST* discard fragmented messages of other types.

Messages larger than the ZeroTier MTU (2800) *MUST* be fragmented.

Implementations *SHOULD* limit the number of unassembled messages
retained for reassembly, to minimize the likelihood of intentional
abuse.  It is suggested that at most 2 unassembled messages be
retained.  It is further suggested that if 2 or more unfragmented
messages arrive before a message is reassembled, or more than 5
seconds pass before the reassembly is complete, that the unassembled
fragments be discarded.







D'Amore                  Expires April 29, 2017                 [Page 6]

Internet-Draft          ZeroTier mapping for SPs            October 2016


Ports
~~~~~

The port numbers are 16-bit fields, allowing a single ZT ID to
service multiple application layer protocols, which could be treated
as seperate end points, or as separate sockets in the application.
The implementation is responsible for discriminating on these and
delivering to the appropriate consumer.

As with UDP or TCP, it is intended that each party have its own port
number, and that a pair of ports (combined with ZeroTier IDs) be used
to identify a single conversation.

An SP server should allocate a port for number advertisement.  It is
expected clients will generate ephemeral port numbers.

Implementations are free to choose how to allocate port numbers, but
it is recommended manually configured port numbers are small, with
the high order bit clear, and that numbers > 32768 (high order bit
set) be used for ephemeral allocations.

It is recommended that separate short queues (perhaps just one or two
messages long) be kept per local port in implementations, to prevent
head-of-line blocking issues where backpressure on one consumer
(perhaps just a single thread or socket) blocks others.

URI Format
~~~~~~~~~~

The URI scheme used to represent ZeroTier addresses makes use of
ZeroTier IDs, ZeroTier network IDs, and our own 16-bit ports.

The format shall be `zt://<nwid>/<ztid>:<port>`, where the `<nwid>`
component represents the 16-digit hexadecimal ZeroTier network ID,
the `<ztid>` represents the 10-digit hexadecimal ZeroTier Device ID,
and the `<port>` is the 16-bit port number previously described.

// XXX: the ztid could use DNS names, generating 6PLANE IP addresses,
// and extracting the 10 digit device id from that.

Security Considerations
~~~~~~~~~~~~~~~~~~~~~~~

The mapping isn't intended to provide any additional security in
addition to what ZeroTier does.



